<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workout Coach V15 - Context Last</title> <!-- V15 -->
    <style>
        /* --- V10 Style Variables --- */
        :root {
            --font-family: Arial, Helvetica, sans-serif;
            --color-bg: #f4f4f4;
            --color-text: #333;
            --color-primary: #007bff;
            /* Blue */
            --color-secondary: #6c757d;
            /* Grey */
            --color-success: #28a745;
            /* Green */
            --color-warning: #ffc107;
            /* Yellow */
            --color-danger: #dc3545;
            /* Red */
            --color-light: #f8f9fa;
            --color-dark: #343a40;
            --color-border: #dee2e6;
            --color-input-bg: #fff;
            --color-header-bg: var(--color-primary);
            --color-header-text: var(--color-light);
            --color-last-session-bg: #e9ecef;
            --color-current-session-bg: var(--color-light);
            --color-button-bg: var(--color-secondary);
            /* Default Button: Grey */
            --color-button-text: var(--color-light);
            --color-button-action-bg: var(--color-success);
            /* Action Button: Green */
            --color-button-action-text: var(--color-light);
            --color-button-toggle-bg: var(--color-primary);
            /* Toggle Button: Blue */
            --color-button-toggle-text: var(--color-light);
            --color-button-disabled-bg: #cccccc;
            --color-button-disabled-border: #aaaaaa;
            --color-button-disabled-text: #666666;
            --color-recommendation: var(--color-primary);
            --color-feedback-success-bg: #d4edda;
            --color-feedback-success-text: #155724;
            --color-feedback-error-bg: #f8d7da;
            --color-feedback-error-text: #721C24;
            --color-plate-3: #dc3545;
            --color-plate-2-5: #007bff;
            --color-plate-1-25: #ffc107;
            --color-handle: #6c757d;
            --float-tolerance: 0.01;
        }

        /* --- Global Styles --- */
        body {
            font-family: var(--font-family);
            background-color: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            padding: 15px;
            font-size: 14px;
            margin: 0;
        }

        .container {
            max-width: 950px;
            margin: 20px auto;
            background-color: #fff;
            border: 1px solid var(--color-border);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        header {
            background-color: var(--color-header-bg);
            color: var(--color-header-text);
            padding: 20px;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        header p {
            margin: 5px 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* --- Buttons (V10 Style) --- */
        button {
            padding: 8px 12px;
            font-size: 0.95em;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            background-color: var(--color-button-bg);
            color: var(--color-button-text);
            margin: 5px 5px 5px 0;
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }

        button:hover:not(:disabled) {
            opacity: 0.85;
        }

        button:disabled {
            background-color: var(--color-button-disabled-bg);
            border-color: var(--color-button-disabled-border);
            color: var(--color-button-disabled-text);
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Specific Button Colors */
        #save-button,
        #complete-button {
            background-color: var(--color-button-action-bg);
            color: var(--color-button-action-text);
            border-color: var(--color-success);
        }

        #prev-button,
        #next-button,
        #cardio-prev-button,
        #cardio-next-button,
        #load-prev-button,
        #back-to-current-button,
        #view-prev-button {
            background-color: var(--color-secondary);
            color: var(--color-button-text);
            border-color: #5a6268;
        }

        #show-double-db-chart-btn,
        #show-single-db-chart-btn {
            background-color: var(--color-button-toggle-bg);
            color: var(--color-button-toggle-text);
            font-size: 0.85em;
            padding: 4px 8px;
            border-color: #0056b3;
        }

        button.active-chart-btn {
            filter: brightness(1.1);
            border-width: 2px;
        }

        /* --- Layout & Panels --- */
        .session-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
        }

        @media (min-width: 768px) {
            .session-container {
                flex-direction: row;
            }

            .session-box {
                flex: 1;
            }
        }

        .session-box {
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 20px;
            background-color: var(--color-light);
        }

        .last-session {
            background-color: var(--color-last-session-bg);
        }

        .current-session {
            background-color: var(--color-current-session-bg);
        }

        .session-box h2 {
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
            font-size: 1.5em;
            text-align: center;
            color: var(--color-primary);
        }

        /* --- Right Panel Content --- */
        #right-panel-content {
            min-height: 300px;
        }

        .exercise {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .exercise h3 {
            margin: 0 0 15px 0;
            font-size: 1.3em;
            color: var(--color-dark);
        }

        .set-block {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed var(--color-border);
        }

        .set-block:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .set-info {
            margin-bottom: 8px;
            font-size: 0.95em;
            color: var(--color-secondary);
        }

        .set-info strong {
            color: var(--color-dark);
        }

        .recommendation {
            color: var(--color-recommendation);
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
            font-size: 1em;
        }

        .last-set-info {
            font-size: 0.9em;
            color: var(--color-secondary);
            margin-bottom: 10px;
            display: block;
        }

        /* Inputs & Selects */
        .input-group label {
            display: inline-block;
            margin-bottom: 3px;
            font-size: 0.9em;
            min-width: 70px;
        }

        input[type="number"],
        input[type="date"],
        select {
            background-color: var(--color-input-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            padding: 8px 10px;
            font-family: var(--font-family);
            font-size: 1em;
            border-radius: 4px;
            width: auto;
            box-sizing: border-box;
            margin-right: 8px;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 75px;
        }

        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
            /* Firefox */
            appearance: none;
            /* Standard property */
        }

        select {
            width: auto;
            min-width: 75px;
        }

        /* --- Jogging Tracker Specific Styles (V10 Theme) --- */
        #jogging-tracker-ui {
            padding: 10px;
        }

        #jogging-session-info {
            margin-bottom: 15px;
            padding: 15px;
            background-color: var(--color-last-session-bg);
            /* Use light grey */
            border: 1px solid var(--color-border);
            border-radius: 4px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            color: var(--color-text);
        }

        #jogging-session-info p {
            margin: 6px 0;
            font-size: 1.1em;
            line-height: 1.4;
        }

        #jogging-session-info strong {
            color: var(--color-primary);
            /* Use primary blue */
            font-weight: bold;
        }

        #jogging-session-info .warmup-label {
            font-weight: normal;
            color: var(--color-secondary);
            font-size: 1.0em;
        }

        #jogging-session-info .warmup-spm {
            color: var(--color-primary);
            font-weight: bold;
        }

        #jogging-session-date {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--color-dark);
            text-align: center;
        }

        #jogging-controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        #no-session-message {
            color: var(--color-danger);
            font-weight: bold;
            font-size: 1.1em;
            text-align: center;
            margin-top: 20px;
        }

        /* --- Other Styles --- */
        #feedback {
            margin-top: 15px;
            font-weight: bold;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid transparent;
        }

        #feedback.success {
            color: var(--color-feedback-success-text);
            background-color: var(--color-feedback-success-bg);
            border-color: #c3e6cb;
        }

        #feedback.error {
            color: var(--color-feedback-error-text);
            background-color: var(--color-feedback-error-bg);
            border-color: #f5c6cb;
        }

        .plate-visualization {
            margin: 5px auto;
            display: flex !important;
            align-items: center !important;
            height: 25px;
            background-color: #e9ecef;
            padding: 4px;
            border-radius: 3px;
            overflow: hidden;
            min-width: 120px;
            justify-content: center;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .plate-visualization .dumbbell-handle {
            height: 8px;
            width: 40px;
            background-color: var(--color-handle);
            margin: 0 2px;
            border-radius: 2px;
            flex-shrink: 0;
            display: inline-block !important;
            visibility: visible !important;
        }

        .plate-visualization .plate {
            height: 100%;
            margin: 0 1px;
            border-radius: 2px;
            display: inline-block !important;
            flex-shrink: 0;
            visibility: visible !important;
        }

        .plate-visualization .plate-3kg {
            background-color: var(--color-plate-3);
            width: 12px;
        }

        .plate-visualization .plate-2-5kg {
            background-color: var(--color-plate-2-5);
            width: 10px;
        }

        .plate-visualization .plate-1-25kg {
            background-color: var(--color-plate-1-25);
            width: 7px;
        }

        .hex-dumbbell-text {
            font-size: 0.9em;
            color: var(--color-secondary);
            margin-top: 8px;
            margin-bottom: 12px;
            display: block !important;
            visibility: visible !important;
        }

        .notes {
            margin-top: 20px;
            padding: 15px;
            font-size: 0.9em;
            color: var(--color-secondary);
            background-color: var(--color-bg);
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        .notes strong {
            color: var(--color-dark);
            font-weight: bold;
        }

        .notes ul {
            padding-left: 20px;
            margin: 5px 0;
        }

        .notes li {
            margin-bottom: 3px;
        }

        #progression-chart-container {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid var(--color-border);
        }

        #chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 5px;
        }

        #chart-title {
            margin: 0;
            text-align: center;
            font-size: 1.2em;
            color: var(--color-secondary);
            flex-grow: 1;
        }

        #chart-toggle-buttons button {
            font-size: 0.85em;
            padding: 4px 8px;
        }

        #progression-chart {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        #progression-chart th,
        #progression-chart td {
            border: 1px solid var(--color-border);
            padding: 6px 8px;
            text-align: center;
            vertical-align: middle;
        }

        #progression-chart th {
            background-color: #e9ecef;
            font-weight: bold;
        }

        #progression-chart td:nth-child(1),
        #progression-chart td:nth-child(2) {
            white-space: nowrap;
        }

        #progression-chart .plate-visualization-cell {
            min-width: 140px;
        }

        #progression-chart .plate-visualization {
            margin: 0 auto;
            height: 20px;
        }

        #prev-date-selector {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        #prev-date-selector label {
            margin-right: 5px;
        }

        #prev-date-selector input[type="date"] {
            padding: 6px;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Workout Coach V15</h1> <!-- V15 -->
            <p id="current-date"></p>
            <p id="workout-type"></p>
            <button id="back-to-current-button" style="display: none; margin-top: 10px;">Back to Today</button>
        </header>

        <!-- Content Area -->
        <div class="session-container">
            <div class="session-box last-session">
                <!-- Last Session Title is now dynamic -->
                <h2 id="left-panel-title">Last Session</h2>
                <div id="last-session-info">
                    <p>Loading last session...</p>
                </div>
                <!-- Strength Retro Controls remain -->
                <button id="view-prev-button">View/Add Previous Strength</button>
                <div id="prev-date-selector" style="display: none;">
                    <label for="prev-date-input">Select Date:</label>
                    <input type="date" id="prev-date-input">
                    <button id="load-prev-button">Load Strength Date</button>
                </div>
                <!-- Chart Area remains -->
                <div id="progression-chart-container">
                    <div id="chart-header">
                        <h3 id="chart-title">Progression Chart</h3>
                        <div id="chart-toggle-buttons">
                            <button id="show-double-db-chart-btn" class="active-chart-btn"
                                title="Show chart for using two identical dumbbells">Double DB</button>
                            <button id="show-single-db-chart-btn" title="Show chart for using only one dumbbell">Single
                                DB</button>
                        </div>
                    </div>
                    <table id="progression-chart">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <!-- Notes remain -->
                <div class="notes">
                    <p><strong>Inv:</strong> 8x3<span style="color:var(--color-plate-3)">■</span> 4x2.5<span
                            style="color:var(--color-plate-2-5)">■</span> 4x1.25<span
                            style="color:var(--color-plate-1-25)">■</span> + 2x10lb Hex</p>
                </div>
            </div>

            <div class="session-box current-session">
                <h2 id="right-panel-title">Today's Plan</h2>
                <div id="right-panel-content"> <!-- Content added by JS --> </div>
                <div id="feedback"></div>
            </div>
        </div> <!-- End Session Container -->
    </div> <!-- End Container -->

    <script>
        const STRENGTH_STORAGE_KEY = 'workoutCoachData_v10';
        const CARDIO_STORAGE_KEY = 'trainingPlanCompletion_v3_nav';
        const STORAGE_KEY_V15 = 'workoutCoachData_v15'; // Placeholder

        // --- Constants (Unchanged) ---
        const PLATES_PER_SIDE_STRICT = { '3': 2, '2.5': 1, '1.25': 1 }; const PLATES_PER_SIDE_SINGLE_DB = { '3': 4, '2.5': 2, '1.25': 2 }; const PLATE_VALUES_DESC = Object.keys(PLATES_PER_SIDE_SINGLE_DB).map(Number).sort((a, b) => b - a); const MAX_WEIGHT_PER_SIDE_STRICT = Object.keys(PLATES_PER_SIDE_STRICT).reduce((sum, val) => sum + parseFloat(val) * PLATES_PER_SIDE_STRICT[val], 0); const MAX_WEIGHT_PER_SIDE_SINGLE_DB = Object.keys(PLATES_PER_SIDE_SINGLE_DB).reduce((sum, val) => sum + parseFloat(val) * PLATES_PER_SIDE_SINGLE_DB[val], 0); const HEX_DUMBBELL_WEIGHT_EACH = 4.5; const HEX_DUMBBELL_WEIGHT_TOTAL = HEX_DUMBBELL_WEIGHT_EACH * 2; const MIN_PLATE_INCREMENT_PER_SIDE = 1.25; const MIN_PLATE_INCREMENT_TOTAL = MIN_PLATE_INCREMENT_PER_SIDE * 2; const STRENGTH_WORKOUT_SCHEDULE = { 2: 'Push', 4: 'Pull', 6: 'Legs' }; const STRENGTH_EXERCISES = { 'Push': ['Incline Bench', 'Overhead Press', 'Chest Fly', 'Triceps Extension', 'Decline Crunch'], 'Pull': ['Bent Over Row', 'Shrug', 'Seated Incline Curls', 'Lateral Raise', 'Lying Leg Raises'], 'Legs': ['Dumbbell Squats', 'Romanian Deadlifts', 'Pullover', 'Standing Calf Raise', 'Planks'] }; const REPS_ONLY_EXERCISES = ['Decline Crunch', 'Lying Leg Raises']; const TIME_BASED_EXERCISES = ['Planks']; const SINGLE_DB_EXERCISES = ['Triceps Extension', 'Pullover']; const NUM_SETS = 3; const TARGET_REPS_MIN = 8; const TARGET_REPS_MAX = 12; const FLOAT_TOLERANCE = 0.01; const RPE_OPTIONS = [{ value: 6, description: "6 (Could do 4 more reps)" }, { value: 7, description: "7 (Definitely 3 more reps)" }, { value: 7.5, description: "7.5 (Maybe 3 more reps)" }, { value: 8, description: "8 (Definitely 2 more reps)" }, { value: 8.5, description: "8.5 (Maybe 2 more reps)" }, { value: 9, description: "9 (Definitely 1 more rep)" }, { value: 9.5, description: "9.5 (Maybe 1 more rep)" }, { value: 10, description: "10 (Couldn't do any more reps)" }]; const CARDIO_START_DATE_STRING = '2025-04-21'; const CARDIO_INITIAL_DISTANCE = 1.75; const CARDIO_INITIAL_SPM = 108; const CARDIO_SESSIONS_PER_CYCLE = 6; const CARDIO_SPM_INCREMENT = 2; const CARDIO_DISTANCE_INCREMENT = 0.25; const CARDIO_SPM_RESET_REDUCTION = 8; const CARDIO_TRAINING_DAYS = [1, 3, 5]; const CARDIO_SESSIONS_TO_GENERATE = 100; const CARDIO_WARMUP_BASE_SPM = 104;

        // --- Global Variables (Unchanged) ---
        let doubleDbWeights = []; let singleDbWeights = []; let cardioSessions = []; let cardioCompletionStatus = {}; let cardioFirstIncompleteIndex = -1; let cardioCurrentlyDisplayedIndex = -1; let strengthData = {}; let currentViewDate = new Date(); let isViewingPreviousStrength = false; let currentChartType = 'double';

        // --- DOM Elements ---
        const currentDateEl = document.getElementById('current-date'); const workoutTypeEl = document.getElementById('workout-type'); const lastSessionInfoEl = document.getElementById('last-session-info'); const rightPanelContentEl = document.getElementById('right-panel-content'); const feedbackEl = document.getElementById('feedback'); const progressionChartTable = document.getElementById('progression-chart'); const chartTitleEl = document.getElementById('chart-title'); const rightPanelTitleEl = document.getElementById('right-panel-title'); const viewPrevButton = document.getElementById('view-prev-button'); const prevDateSelectorDiv = document.getElementById('prev-date-selector'); const prevDateInput = document.getElementById('prev-date-input'); const loadPrevButton = document.getElementById('load-prev-button'); const backToCurrentButton = document.getElementById('back-to-current-button'); const showDoubleDbBtn = document.getElementById('show-double-db-chart-btn'); const showSingleDbBtn = document.getElementById('show-single-db-chart-btn');
        const leftPanelTitleEl = document.getElementById('left-panel-title'); // <-- Get left panel title

        // --- Utility Functions (Unchanged) ---
        function getFormattedDate(date) { /*...*/ const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }
        function loadStrengthData() { /*...*/ const data = localStorage.getItem(STRENGTH_STORAGE_KEY); return data ? JSON.parse(data) : {}; }
        function saveStrengthData(data) { /*...*/ localStorage.setItem(STRENGTH_STORAGE_KEY, JSON.stringify(data)); }
        function loadCardioCompletionStatus() { /*...*/ const storedStatus = localStorage.getItem(CARDIO_STORAGE_KEY); return storedStatus ? JSON.parse(storedStatus) : {}; }
        function saveCardioCompletionStatus() { /*...*/ localStorage.setItem(CARDIO_STORAGE_KEY, JSON.stringify(cardioCompletionStatus)); }
        function getPermutations(arr) { /*...*/ const result = []; const n = arr.length; const c = new Array(n).fill(0); let k; let p; result.push([...arr]); let i = 1; while (i < n) { if (c[i] < i) { k = i % 2 && c[i]; p = arr[i]; arr[i] = arr[k]; arr[k] = p; ++c[i]; i = 1; result.push([...arr]); } else { c[i] = 0; ++i; } } return result; }
        function countPlateDiffs(plates1, plates2) { /*...*/ const counts1 = plates1.reduce((acc, p) => { acc[p] = (acc[p] || 0) + 1; return acc; }, {}); const counts2 = plates2.reduce((acc, p) => { acc[p] = (acc[p] || 0) + 1; return acc; }, {}); let removed = 0; let added = 0; const allPlates = new Set([...plates1, ...plates2]); allPlates.forEach(p => { const c1 = counts1[p] || 0; const c2 = counts2[p] || 0; if (c1 > c2) removed += (c1 - c2); if (c2 > c1) added += (c2 - c1); }); return { removed, added }; }
        function parseDate(dateString) { /*...*/ const [year, month, day] = dateString.split('-').map(Number); return new Date(Date.UTC(year, month - 1, day)); }
        function formatDate(date) { // From tracker, needed by generateCardioSessions
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // --- Generate Weights Functions (Unchanged) ---
        function generateDoubleDbWeights() { /* ... same ... */ const possibleWeightsPerSide = new Map(); const plateTypes = PLATE_VALUES_DESC; const maxCounts = PLATES_PER_SIDE_STRICT; function findCombinations(plateIndex, currentWeight, currentPlateCombo) { const weightKey = parseFloat(currentWeight.toFixed(3)); if (weightKey >= MIN_PLATE_INCREMENT_PER_SIDE) { if (!possibleWeightsPerSide.has(weightKey) || possibleWeightsPerSide.get(weightKey).plates.length > currentPlateCombo.length) { possibleWeightsPerSide.set(weightKey, { weight: weightKey, plates: [...currentPlateCombo].sort((a, b) => b - a) }); } } else if (weightKey === 0) { if (!possibleWeightsPerSide.has(weightKey)) { possibleWeightsPerSide.set(weightKey, { weight: weightKey, plates: [] }); } } if (plateIndex >= plateTypes.length) return; const currentPlateValue = plateTypes[plateIndex]; const currentPlateKey = String(currentPlateValue); const maxCountForPlate = maxCounts[currentPlateKey]; for (let count = 0; count <= maxCountForPlate; count++) { const nextWeight = currentWeight + count * currentPlateValue; if (nextWeight > MAX_WEIGHT_PER_SIDE_STRICT + FLOAT_TOLERANCE) break; for (let i = 0; i < count; i++) currentPlateCombo.push(currentPlateValue); findCombinations(plateIndex + 1, nextWeight, currentPlateCombo); for (let i = 0; i < count; i++) currentPlateCombo.pop(); } } findCombinations(0, 0, []); const finalWeights = []; for (const [weightKey, data] of possibleWeightsPerSide.entries()) { if (data.weight >= MIN_PLATE_INCREMENT_PER_SIDE) { finalWeights.push({ total: data.weight * 4, perDb: data.weight * 2, platesPerSide: data.plates }); } } console.log("Generated Double DB Weights:", finalWeights); return finalWeights.sort((a, b) => a.total - b.total); }
        function generateSingleDbWeights() { /* ... same ... */ const possibleWeightsPerSide = new Map(); const plateTypes = PLATE_VALUES_DESC; const maxCounts = PLATES_PER_SIDE_SINGLE_DB; function findCombinations(plateIndex, currentWeight, currentPlateCombo) { const weightKey = parseFloat(currentWeight.toFixed(3)); if (weightKey > 0) { if (!possibleWeightsPerSide.has(weightKey) || possibleWeightsPerSide.get(weightKey).plates.length > currentPlateCombo.length) { possibleWeightsPerSide.set(weightKey, { weight: weightKey, plates: [...currentPlateCombo].sort((a, b) => b - a) }); } } else if (weightKey === 0) { if (!possibleWeightsPerSide.has(weightKey)) { possibleWeightsPerSide.set(weightKey, { weight: weightKey, plates: [] }); } } if (plateIndex >= plateTypes.length) return; const currentPlateValue = plateTypes[plateIndex]; const currentPlateKey = String(currentPlateValue); const maxCountForPlate = maxCounts[currentPlateKey]; for (let count = 0; count <= maxCountForPlate; count++) { const nextWeight = currentWeight + count * currentPlateValue; if (nextWeight > MAX_WEIGHT_PER_SIDE_SINGLE_DB + FLOAT_TOLERANCE) break; for (let i = 0; i < count; i++) currentPlateCombo.push(currentPlateValue); findCombinations(plateIndex + 1, nextWeight, currentPlateCombo); for (let i = 0; i < count; i++) currentPlateCombo.pop(); } } findCombinations(0, 0, []); const finalWeights = []; for (const [weightKey, data] of possibleWeightsPerSide.entries()) { if (data.weight > 0) { finalWeights.push({ perDb: data.weight * 2, platesPerSide: data.plates }); } } console.log("Generated Single DB Weights:", finalWeights); return finalWeights.sort((a, b) => a.perDb - b.perDb); }


        // --- Strength Recommendation Logic (V16 - Uses Exercise-Specific Rep Ranges) ---
        function getStrengthRecommendation(exerciseName, lastSetData) {
            const isSingleDBExercise = SINGLE_DB_EXERCISES.includes(exerciseName);
            const isWeighted = !REPS_ONLY_EXERCISES.includes(exerciseName) && !TIME_BASED_EXERCISES.includes(exerciseName);

            // --- Determine Target Rep Range for THIS exercise ---
            const repRange = SPECIFIC_REP_RANGES[exerciseName] || DEFAULT_REP_RANGE;
            const targetMinReps = repRange.min;
            const targetMaxReps = repRange.max;
            // ---

            if (!isWeighted) { // Handle non-weighted (Use default range for rep target if applicable)
                if (TIME_BASED_EXERCISES.includes(exerciseName)) { const lastTime = lastSetData?.time; return { weight: null, reps: null, time: lastTime ? lastTime + 5 : 30, platesPerSide: [] }; }
                else { const lastReps = lastSetData?.reps; return { weight: null, reps: lastReps ? lastReps + 1 : targetMinReps, time: null, platesPerSide: [] }; } // Default to min reps of its range
            }

            const chartData = isSingleDBExercise ? singleDbWeights : doubleDbWeights;
            const searchKey = isSingleDBExercise ? 'perDb' : 'total';
            const chartName = isSingleDBExercise ? 'Single DB Chart' : 'Double DB Chart';

            if (chartData.length === 0) { console.error(`${chartName} not generated yet!`); return { weight: null, reps: null, time: null, platesPerSide: [] }; }

            let lastWeight = null; if (lastSetData && typeof lastSetData.weight === 'number') { lastWeight = lastSetData.weight; }
            let lastWeightIndex = -1;

            if (lastWeight !== null && Math.abs(lastWeight - HEX_DUMBBELL_WEIGHT_TOTAL) < FLOAT_TOLERANCE && !isSingleDBExercise) { /* ... hex mapping ... */ let closestIndex = 0; let minDist = Infinity; chartData.forEach((step, index) => { const dist = Math.abs(step.total - HEX_DUMBBELL_WEIGHT_TOTAL); if (dist < minDist) { minDist = dist; closestIndex = index; } }); lastWeightIndex = closestIndex; console.log(`Mapping last Hex DB weight (${lastWeight}kg) to chart index ${lastWeightIndex} (${chartData[closestIndex].total}kg)`); }
            else if (lastWeight !== null) { /* ... exact match ... */ lastWeightIndex = chartData.findIndex(step => Math.abs(step[searchKey] - lastWeight) < FLOAT_TOLERANCE); console.log(`Searching for ${lastWeight}kg in ${searchKey} column of ${chartName}. Found index: ${lastWeightIndex}`); }

            if (lastWeightIndex === -1) { /* ... default index ... */ console.log(`No valid last weight found for ${exerciseName}. Starting at index 0 of ${chartName}.`); lastWeightIndex = 0; if (!isSingleDBExercise && HEX_DUMBBELL_WEIGHT_TOTAL < chartData[0].total) { console.log(`Defaulting ${exerciseName} to Hex Dumbbells...`); return { weight: HEX_DUMBBELL_WEIGHT_TOTAL, reps: targetMinReps, time: null, platesPerSide: [], isHex: true }; } } // Use targetMinReps

            // --- Progression direction logic using exercise-specific ranges ---
            let indexChange = 0;
            let recommendedReps = targetMinReps; // Default to min reps for the range

            if (lastSetData) {
                const { reps, rpe } = lastSetData;
                if (reps >= targetMaxReps && rpe <= 8) { // Hit TOP of range easily
                    indexChange = 1; // Go up in weight
                    recommendedReps = targetMinReps; // Reset reps to bottom of range
                    console.log(`${exerciseName}: Progressing UP ${chartName} weight`);
                } else if (reps < targetMinReps && rpe >= 9.5) { // Failed BOTTOM of range at high effort
                    indexChange = -1; // Go down in weight
                    recommendedReps = targetMinReps; // Aim for bottom reps with lighter weight
                    console.log(`${exerciseName}: Regressing DOWN ${chartName} weight`);
                } else { // Stay at same weight, adjust reps?
                    indexChange = 0;
                    // If easy/mid RPE and not max reps, try adding a rep next time
                    if (reps < targetMaxReps && rpe <= 8.5) {
                        recommendedReps = reps + 1;
                    } else { // Otherwise, stick to same reps or min reps
                        recommendedReps = Math.max(targetMinReps, reps); // Keep current reps or min
                    }
                    console.log(`${exerciseName}: Staying at same ${chartName} step, aiming for ~${recommendedReps} reps`);
                }
            } else { // No last set data, default to min reps
                recommendedReps = targetMinReps;
                console.log(`${exerciseName}: No last set data, staying at determined index, aiming for ${recommendedReps} reps`);
            }
            // --- End Progression Logic ---

            let newIndex = lastWeightIndex + indexChange;
            newIndex = Math.max(0, Math.min(newIndex, chartData.length - 1));

            const recommendedWeightInfo = chartData[newIndex];
            const recommendedWeight = recommendedWeightInfo[searchKey];

            console.log(`${exerciseName}: Recommended Index: ${newIndex}, Weight: ${recommendedWeight}kg (${searchKey}), Reps: ${recommendedReps}`);
            return { weight: recommendedWeight, reps: recommendedReps, time: null, platesPerSide: recommendedWeightInfo.platesPerSide, isHex: false };
        }

        // --- Strength Sequencing Logic (Unchanged) ---
        function calculateStrengthTransitionCost(rec1, rec2) { /* ... same ... */ const loadout1 = rec1.isHex ? [] : rec1.platesPerSide; const loadout2 = rec2.isHex ? [] : rec2.platesPerSide; const isSingle1 = SINGLE_DB_EXERCISES.includes(rec1.exerciseName); const isSingle2 = SINGLE_DB_EXERCISES.includes(rec2.exerciseName); const diff = countPlateDiffs(loadout1, loadout2); let cost = 0; if (!isSingle1 && !isSingle2) { cost = (diff.removed + diff.added) * 2; } else if (!isSingle1 && isSingle2) { cost = (diff.removed + diff.added) + loadout1.length + loadout1.length * 2; } else if (isSingle1 && !isSingle2) { cost = (diff.removed + diff.added) + loadout2.length + loadout2.length * 2; } else { cost = (diff.removed + diff.added) * 2; } return cost; }
        function getOptimalStrengthSequence(exerciseNames, recommendations) { /* ... same ... */ const weightedExercises = exerciseNames.filter(name => recommendations[name] && typeof recommendations[name].weight === 'number' && recommendations[name].weight > 0).map(name => ({ exerciseName: name, ...recommendations[name] })); const nonWeightedExercises = exerciseNames.filter(name => !recommendations[name] || typeof recommendations[name].weight !== 'number' || recommendations[name].weight <= 0); if (weightedExercises.length <= 1) return [...weightedExercises.map(e => e.exerciseName), ...nonWeightedExercises]; let bestSequence = [...weightedExercises]; let minTotalCost = Infinity; const permutations = getPermutations(weightedExercises); console.log(`Evaluating ${permutations.length} strength sequence permutations...`); permutations.forEach(sequence => { let currentTotalCost = 0; const firstRec = sequence[0]; currentTotalCost += firstRec.isHex ? 0 : (firstRec.platesPerSide.length * (SINGLE_DB_EXERCISES.includes(firstRec.exerciseName) ? 2 : 4)); for (let i = 0; i < sequence.length - 1; i++) { currentTotalCost += calculateStrengthTransitionCost(sequence[i], sequence[i + 1]); } const lastRec = sequence[sequence.length - 1]; currentTotalCost += lastRec.isHex ? 0 : (lastRec.platesPerSide.length * (SINGLE_DB_EXERCISES.includes(lastRec.exerciseName) ? 2 : 4)); if (currentTotalCost < minTotalCost) { minTotalCost = currentTotalCost; bestSequence = [...sequence]; } }); console.log(`Optimal strength sequence found with cost ${minTotalCost}: ${bestSequence.map(e => e.exerciseName).join(', ')}`); return [...bestSequence.map(e => e.exerciseName), ...nonWeightedExercises]; }

        // --- Cardio Logic (Unchanged) ---
        function calculateWarmupSPM(targetSPM, percentage) { /*...*/ if (targetSPM <= CARDIO_WARMUP_BASE_SPM) return CARDIO_WARMUP_BASE_SPM; return Math.ceil(CARDIO_WARMUP_BASE_SPM + (percentage / 100) * (targetSPM - CARDIO_WARMUP_BASE_SPM)); }
        function generateCardioSessions() { /*...*/ const sessions = []; let currentDate = parseDate(CARDIO_START_DATE_STRING); let currentDistance = CARDIO_INITIAL_DISTANCE; let currentCycleStartSPM = CARDIO_INITIAL_SPM; let sessionCounterInCycle = 0; let sessionsGenerated = 0; while (!CARDIO_TRAINING_DAYS.includes(currentDate.getUTCDay())) { currentDate.setUTCDate(currentDate.getUTCDate() + 1); } while (sessionsGenerated < CARDIO_SESSIONS_TO_GENERATE) { if (CARDIO_TRAINING_DAYS.includes(currentDate.getUTCDay())) { const targetSPM = currentCycleStartSPM + (sessionCounterInCycle * CARDIO_SPM_INCREMENT); sessions.push({ date: formatDate(currentDate), distance: parseFloat(currentDistance.toFixed(2)), spm: targetSPM, originalIndex: sessionsGenerated }); sessionCounterInCycle++; sessionsGenerated++; if (sessionCounterInCycle >= CARDIO_SESSIONS_PER_CYCLE) { currentDistance += CARDIO_DISTANCE_INCREMENT; const lastSPMOfCycle = currentCycleStartSPM + ((CARDIO_SESSIONS_PER_CYCLE - 1) * CARDIO_SPM_INCREMENT); currentCycleStartSPM = lastSPMOfCycle - CARDIO_SPM_RESET_REDUCTION; sessionCounterInCycle = 0; } } currentDate.setUTCDate(currentDate.getUTCDate() + 1); } return sessions; }
        function findFirstIncompleteCardioIndex() { /*...*/ for (let i = 0; i < cardioSessions.length; i++) { if (!cardioCompletionStatus[cardioSessions[i].date]) { return i; } } return -1; }

        // --- Rendering Functions ---

        // Visualization (Unchanged)
        function renderPlateVisualizationHTML(weightPerDb, platesPerSide = null) { /* ... same ... */ if (weightPerDb === null || weightPerDb <= 0) return ''; if (Math.abs(weightPerDb - HEX_DUMBBELL_WEIGHT_EACH) < FLOAT_TOLERANCE) { return `<div class="hex-dumbbell-text">10lb Hex DB</div>`; } if (weightPerDb < MIN_PLATE_INCREMENT_TOTAL) return ''; let plates = platesPerSide; if (!plates) { console.error(`Plates per side array missing for visualization of ${weightPerDb}kg per DB`); return '<span style="font-size:0.8em; color:var(--color-danger);">Viz Error</span>'; } if (!Array.isArray(plates)) { console.error(`platesPerSide is not an array for ${weightPerDb}kg:`, plates); return '<span style="font-size:0.8em; color:var(--color-danger);">Data Error</span>'; } const plateHtml = (p) => { let plateClass = ''; if (Math.abs(p - 3) < FLOAT_TOLERANCE) plateClass = 'plate-3kg'; else if (Math.abs(p - 2.5) < FLOAT_TOLERANCE) plateClass = 'plate-2-5kg'; else if (Math.abs(p - 1.25) < FLOAT_TOLERANCE) plateClass = 'plate-1-25kg'; return `<div class="plate ${plateClass}" title="${p}kg"></div>`; }; const leftPlatesHtml = plates.map(plateHtml).join(''); const rightPlatesHtml = [...plates].reverse().map(plateHtml).join(''); return `<div class="plate-visualization" style="visibility: visible !important; display: flex !important;" title="Dumbbell Loadout: ${weightPerDb.toFixed(2)}kg"> ${leftPlatesHtml} <div class="dumbbell-handle"></div> ${rightPlatesHtml} </div>`; }

        // Render Chart (Unchanged)
        function renderProgressionChart(chartType) { /* ... same ... */ const tableHead = progressionChartTable.querySelector('thead'); const tableBody = progressionChartTable.querySelector('tbody'); tableHead.innerHTML = ''; tableBody.innerHTML = ''; const data = (chartType === 'single') ? singleDbWeights : doubleDbWeights; const isSingle = (chartType === 'single'); const headerRow = tableHead.insertRow(); if (!isSingle) { headerRow.insertCell().textContent = 'Total (kg)'; } headerRow.insertCell().textContent = 'Per DB (kg)'; headerRow.insertCell().textContent = 'Loadout (Per DB)'; data.forEach(weightInfo => { const row = tableBody.insertRow(); if (!isSingle) { row.insertCell().textContent = weightInfo.total.toFixed(2); } row.insertCell().textContent = weightInfo.perDb.toFixed(2); const cellViz = row.insertCell(); cellViz.classList.add('plate-visualization-cell'); cellViz.innerHTML = renderPlateVisualizationHTML(weightInfo.perDb, weightInfo.platesPerSide); }); }

        // Render Last Session Panel V15 - Context Aware *** NEW ***
        function renderLastSessionPanel(todayWorkoutInfo) {
            let lastSessionDateStr = null;
            let lastSessionData = null;
            let title = "Last Session"; // Default title

            if (todayWorkoutInfo.category === 'Strength') {
                // Find last session of the *same type* (Push/Pull/Legs)
                lastSessionDateStr = findLastSessionDate(currentViewDate, todayWorkoutInfo.type, strengthData);
                lastSessionData = lastSessionDateStr ? strengthData[lastSessionDateStr] : null;
                title = lastSessionData ? `Last ${lastSessionData.type} Session` : "No Prior Strength Data";
            }
            else if (todayWorkoutInfo.category === 'Cardio') {
                // Find the most recently *completed* cardio session before today
                const sortedCardioDates = cardioSessions.map(s => s.date).sort().reverse();
                for (const dateStr of sortedCardioDates) {
                    if (dateStr < getFormattedDate(currentViewDate) && cardioCompletionStatus[dateStr]) {
                        lastSessionDateStr = dateStr;
                        break;
                    }
                }
                // Find the session details from the cardioSessions array
                lastSessionData = lastSessionDateStr ? cardioSessions.find(s => s.date === lastSessionDateStr) : null;
                title = lastSessionData ? "Last Cardio Session" : "No Prior Cardio Data";
            }
            else { // Rest Day - Find the absolute most recent workout (Strength or Completed Cardio)
                const lastStrengthDate = findLastSessionDate(currentViewDate, null, strengthData, true); // Ignore type
                const sortedCardioDates = cardioSessions.map(s => s.date).sort().reverse();
                let lastCompletedCardioDate = null;
                for (const dateStr of sortedCardioDates) { if (dateStr < getFormattedDate(currentViewDate) && cardioCompletionStatus[dateStr]) { lastCompletedCardioDate = dateStr; break; } }

                if (lastStrengthDate && (!lastCompletedCardioDate || lastStrengthDate > lastCompletedCardioDate)) {
                    lastSessionDateStr = lastStrengthDate;
                    lastSessionData = strengthData[lastSessionDateStr];
                    title = `Last Workout (${lastSessionData.type})`;
                } else if (lastCompletedCardioDate) {
                    lastSessionDateStr = lastCompletedCardioDate;
                    lastSessionData = cardioSessions.find(s => s.date === lastSessionDateStr);
                    title = "Last Workout (Cardio)";
                } else {
                    title = "No Prior Workout Data";
                }
            }

            // Update the panel title
            leftPanelTitleEl.textContent = title;

            // --- Render the content ---
            if (!lastSessionData) {
                lastSessionInfoEl.innerHTML = '<p>No previous session data found for this type.</p>';
                return;
            }

            // Check if it's strength or cardio data based on presence of 'exercises' or 'distance'
            if (lastSessionData.exercises) { // Strength Data
                let html = `<p style="text-align: center; margin-bottom: 5px;"><strong>${lastSessionData.date}</strong></p>`;
                const strengthType = lastSessionData.type; // e.g., 'Push'
                const originalOrder = STRENGTH_EXERCISES[strengthType] || Object.keys(lastSessionData.exercises);
                originalOrder.forEach(exerciseName => {
                    if (!lastSessionData.exercises[exerciseName]) return;
                    html += `<div class="exercise"><h5>${exerciseName}</h5>`;
                    html += lastSessionData.exercises[exerciseName].map((set, index) => {
                        let setDetails = ''; const setData = set || {};
                        if (TIME_BASED_EXERCISES.includes(exerciseName)) setDetails = `T: ${setData.time ?? 'N/A'}s @ ${setData.rpe ?? 'N/A'}`;
                        else if (REPS_ONLY_EXERCISES.includes(exerciseName)) setDetails = `R: ${setData.reps ?? 'N/A'} @ ${setData.rpe ?? 'N/A'}`;
                        else setDetails = `W: ${setData.weight ?? 'N/A'}kg x ${setData.reps ?? 'N/A'}r @ ${setData.rpe ?? 'N/A'}`;
                        return `<div class="set-info" style="font-size: 0.9em;">S${index + 1}: ${setDetails}</div>`;
                    }).join('');
                    html += `</div>`;
                });
                lastSessionInfoEl.innerHTML = html;
            }
            else if (lastSessionData.distance !== undefined) { // Cardio Data
                const displayDate = parseDate(lastSessionData.date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC' });
                lastSessionInfoEl.innerHTML = `
                    <p style="text-align:center; margin-bottom: 10px;"><strong>${displayDate.toUpperCase()}</strong></p>
                    <p>Distance: <strong>${lastSessionData.distance.toFixed(2)} KM</strong></p>
                    <p>Target SPM: <strong>${lastSessionData.spm}</strong></p>
                    <p>(Marked Complete)</p>
                 `;
            } else {
                lastSessionInfoEl.innerHTML = '<p>Could not display last session data.</p>';
            }
        }
        // Helper to find the last session date - Modified for V15
        function findLastSessionDate(currentDate, workoutType, allData, ignoreType = false) {
            let lastDate = null;
            const sortedDates = Object.keys(allData).sort().reverse(); // Sort descending
            const todayStr = getFormattedDate(currentDate);

            for (const dateStr of sortedDates) {
                // Only consider dates *before* the current date being viewed/evaluated
                if (dateStr < todayStr) {
                    // If ignoring type, just take the first one found.
                    // If workoutType is provided, check for match.
                    if (ignoreType || allData[dateStr]?.type === workoutType) {
                        lastDate = dateStr;
                        break;
                    }
                }
            }
            return lastDate;
        }


        // Render Strength Panel V16 - Displays target rep range
        function renderStrengthPanel(targetDate, exercisesToShow, sessionData, options = {}) {
            const { isPast = false } = options;
            let strengthHTML = `<form id="current-session-form">`;

            exercisesToShow.forEach(exerciseName => {
                // --- Get target rep range for display ---
                const repRange = SPECIFIC_REP_RANGES[exerciseName] || DEFAULT_REP_RANGE;
                const displayRepRange = `${repRange.min}-${repRange.max} Reps`;
                // ---

                strengthHTML += `<div class="exercise"><h3>${exerciseName} <span style="font-size: 0.8em; color: var(--color-secondary); font-weight: normal;">(${displayRepRange})</span></h3>`; // Display range in title

                const existingSetsForDate = sessionData?.exercises?.[exerciseName] ?? [];
                const shouldShowRecommendation = !isPast || (isPast && existingSetsForDate.length === 0);
                let currentRec = null;
                if (shouldShowRecommendation) { const workoutType = STRENGTH_WORKOUT_SCHEDULE[targetDate.getDay()]; const lastRelevantSessionDateStr = findLastSessionDate(targetDate, workoutType, strengthData); const lastRelevantSessionData = lastRelevantSessionDateStr ? strengthData[lastRelevantSessionDateStr] : null; const lastSetFromRelevantSession = lastRelevantSessionData?.exercises?.[exerciseName]?.slice(-1)[0] ?? null; currentRec = getStrengthRecommendation(exerciseName, lastSetFromRelevantSession); }

                const isRepsOnly = REPS_ONLY_EXERCISES.includes(exerciseName); const isTimeBased = TIME_BASED_EXERCISES.includes(exerciseName);
                const isWeighted = !isRepsOnly && !isTimeBased; const isSingleDB = SINGLE_DB_EXERCISES.includes(exerciseName);

                for (let i = 0; i < NUM_SETS; i++) {
                    const setIndex = i; const existingSetData = existingSetsForDate[setIndex] ?? null;
                    strengthHTML += `<div class="set-block"><strong>Set ${setIndex + 1}</strong>`;
                    if (!isPast) { /* ... Add Last: info ... */ const lastSessionDateStrForInfo = findLastSessionDate(targetDate, STRENGTH_WORKOUT_SCHEDULE[targetDate.getDay()], strengthData); const lastSessionActualForInfo = lastSessionDateStrForInfo ? strengthData[lastSessionDateStrForInfo] : null; const lastSetActualForInfo = lastSessionActualForInfo?.exercises?.[exerciseName]?.[setIndex] ?? null; let lastSetInfoHtml = 'N/A'; if (lastSetActualForInfo) { if (isTimeBased) lastSetInfoHtml = `${lastSetActualForInfo.time ?? 'N/A'}s @ RPE ${lastSetActualForInfo.rpe ?? 'N/A'}`; else if (isRepsOnly) lastSetInfoHtml = `${lastSetActualForInfo.reps ?? 'N/A'}r @ RPE ${lastSetActualForInfo.rpe ?? 'N/A'}`; else lastSetInfoHtml = `${lastSetActualForInfo.weight ?? 'N/A'}kg x ${lastSetActualForInfo.reps ?? 'N/A'}r @ RPE ${lastSetActualForInfo.rpe ?? 'N/A'}`; } strengthHTML += `<span class="last-set-info">Last: ${lastSetInfoHtml}</span>`; }
                    if (shouldShowRecommendation) { /* ... Add Recommendation ... */ if (isWeighted && currentRec?.weight !== null) { const displayWeight = currentRec.weight; const displayWeightUnit = isSingleDB ? "kg (Single DB)" : "kg (Total)"; strengthHTML += `<span class="recommendation">Recommend: ${displayWeight.toFixed(2)} ${displayWeightUnit} x ${currentRec.reps} reps</span>`; const weightPerDbForViz = isSingleDB ? currentRec.weight : currentRec.weight / 2; strengthHTML += renderPlateVisualizationHTML(weightPerDbForViz, currentRec.platesPerSide); } else if (isRepsOnly && currentRec?.reps !== null) { strengthHTML += `<span class="recommendation">Aim for ${currentRec.reps} reps</span>`; } else if (isTimeBased && currentRec?.time !== null) { strengthHTML += `<span class="recommendation">Aim for ${currentRec.time} sec</span>`; } }
                    strengthHTML += `<div class="input-group">`; // Inputs
                    if (isWeighted) { const prevWeight = existingSetData?.weight ?? ''; strengthHTML += `<label for="weight-${exerciseName}-${setIndex}">Weight:</label><input type="number" value="${prevWeight}" id="weight-${exerciseName}-${setIndex}" name="weight-${exerciseName}-${setIndex}" step="${MIN_PLATE_INCREMENT_PER_SIDE}" min="0" required>`; } if (!isTimeBased) { const prevReps = existingSetData?.reps ?? ''; strengthHTML += `<label for="reps-${exerciseName}-${setIndex}">${isRepsOnly ? 'Reps:' : 'Reps:'}</label><input type="number" value="${prevReps}" id="reps-${exerciseName}-${setIndex}" name="reps-${exerciseName}-${setIndex}" min="0" required>`; } else { const prevTime = existingSetData?.time ?? ''; strengthHTML += `<label for="time-${exerciseName}-${setIndex}">Time:</label><input type="number" value="${prevTime}" id="time-${exerciseName}-${setIndex}" name="time-${exerciseName}-${setIndex}" min="0" required>`; } const prevRpe = existingSetData?.rpe ?? ''; strengthHTML += `<label for="rpe-${exerciseName}-${setIndex}">RPE:</label><select id="rpe-${exerciseName}-${setIndex}" name="rpe-${exerciseName}-${setIndex}" required>`; strengthHTML += `<option value="" ${prevRpe === '' ? 'selected' : ''}>--</option>`; RPE_OPTIONS.forEach(rpeOption => { const isSelected = prevRpe !== '' && Math.abs(parseFloat(prevRpe) - rpeOption.value) < FLOAT_TOLERANCE; strengthHTML += `<option value="${rpeOption.value}" ${isSelected ? 'selected' : ''}>${rpeOption.value}</option>`; }); strengthHTML += `</select>`; strengthHTML += `</div></div>`;
                }
                strengthHTML += `</div>`;
            });
            strengthHTML += `<button type="button" id="save-button">${isPast ? (sessionData ? 'Update Past Strength' : 'Save Past Strength') : 'Save Strength Session'}</button></form>`;
            rightPanelContentEl.innerHTML = strengthHTML;
            const saveBtn = document.getElementById('save-button');
            if (saveBtn) { saveBtn.addEventListener('click', handleStrengthSave); }
        }

        // Render Cardio Panel (Unchanged)
        function renderCardioPanel(cardioSessionIndex) { /* ... same ... */ cardioCurrentlyDisplayedIndex = cardioSessionIndex; let cardioHTML = `<div id="jogging-tracker-ui">`; if (cardioSessionIndex >= 0 && cardioSessionIndex < cardioSessions.length) { const session = cardioSessions[cardioSessionIndex]; const displayDate = parseDate(session.date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC' }); let w1 = '---'; let w2 = '---'; let w3 = '---'; const tolerance = 0.001; if (Math.abs(session.distance - 1.75) < tolerance) w1 = calculateWarmupSPM(session.spm, 66); else if (Math.abs(session.distance - 2.00) < tolerance) { w1 = calculateWarmupSPM(session.spm, 50); w2 = calculateWarmupSPM(session.spm, 75); } else if (session.distance >= 2.25 - tolerance) { w1 = calculateWarmupSPM(session.spm, 25); w2 = calculateWarmupSPM(session.spm, 50); w3 = calculateWarmupSPM(session.spm, 75); } cardioHTML += `<div id="jogging-session-info"><p id="jogging-session-date">DATE: ${displayDate.toUpperCase()}</p><p>DISTANCE: <strong>${session.distance.toFixed(2)} KM</strong></p><p><span class="warmup-label">WARMUP 1:</span> <span class="warmup-spm">${w1}</span></p><p><span class="warmup-label">WARMUP 2:</span> <span class="warmup-spm">${w2}</span></p><p><span class="warmup-label">WARMUP 3:</span> <span class="warmup-spm">${w3}</span></p><p>TARGET SPM: <strong>${session.spm}</strong></p></div><div id="jogging-controls"><button id="cardio-prev-button" ${cardioSessionIndex <= cardioFirstIncompleteIndex ? 'disabled' : ''}>< PREV</button><button id="complete-button" style="${cardioSessionIndex === cardioFirstIncompleteIndex ? 'display: inline-block;' : 'display: none;'}">MARK COMPLETE</button><button id="cardio-next-button" ${cardioSessionIndex >= cardioSessions.length - 1 ? 'disabled' : ''}>NEXT ></button></div>`; } else { cardioHTML += `<div id="no-session-message">CARDIO PLAN COMPLETE!</div>`; } cardioHTML += `</div>`; rightPanelContentEl.innerHTML = cardioHTML; const completeBtn = document.getElementById('complete-button'); const prevBtn = document.getElementById('cardio-prev-button'); const nextBtn = document.getElementById('cardio-next-button'); if (completeBtn) completeBtn.addEventListener('click', handleCardioMarkComplete); if (prevBtn) prevBtn.addEventListener('click', handleCardioPrevious); if (nextBtn) nextBtn.addEventListener('click', handleCardioNext); }

        // --- Event Handlers (Unchanged) ---
        function handleStrengthSave() { /* ... same ... */ feedbackEl.textContent = ''; feedbackEl.className = ''; const dateToSave = isViewingPreviousStrength ? new Date(prevDateInput.value + 'T00:00:00') : new Date(); const dateFormatted = getFormattedDate(dateToSave); const workoutInfo = STRENGTH_WORKOUT_SCHEDULE[dateToSave.getDay()]; if (!workoutInfo) { feedbackEl.textContent = `Selected date (${dateFormatted}) is not a strength day. Cannot save.`; feedbackEl.className = 'error'; return; } if (!strengthData[dateFormatted]) { strengthData[dateFormatted] = { date: dateFormatted, type: workoutInfo, exercises: {} }; } else { strengthData[dateFormatted].type = workoutInfo; strengthData[dateFormatted].exercises = {}; } const sessionData = strengthData[dateFormatted]; let formIsValid = true; const exercisesToSave = STRENGTH_EXERCISES[workoutInfo]; exercisesToSave.forEach(exerciseName => { sessionData.exercises[exerciseName] = []; const isRepsOnly = REPS_ONLY_EXERCISES.includes(exerciseName); const isTimeBased = TIME_BASED_EXERCISES.includes(exerciseName); for (let i = 0; i < NUM_SETS; i++) { const setIndex = i; const rpeInput = document.getElementById(`rpe-${exerciseName}-${setIndex}`); if (!rpeInput) { console.warn(`Input not found for ${exerciseName} Set ${i + 1} RPE`); continue; } const rpe = parseFloat(rpeInput.value); let setData = { weight: null, reps: null, time: null, rpe: null }; const isValidRpe = RPE_OPTIONS.some(opt => opt.value === rpe); if (isNaN(rpe) || !isValidRpe) { formIsValid = false; if (rpeInput) rpeInput.style.borderColor = 'var(--color-danger)'; } else { setData.rpe = rpe; if (rpeInput) rpeInput.style.borderColor = ''; } if (isTimeBased) { const timeInput = document.getElementById(`time-${exerciseName}-${setIndex}`); if (!timeInput) { console.warn(`Input not found for ${exerciseName} Set ${i + 1} Time`); continue; } const time = parseInt(timeInput.value, 10); if (isNaN(time) || time < 0) { formIsValid = false; if (timeInput) timeInput.style.borderColor = 'var(--color-danger)'; } else { setData.time = time; if (timeInput) timeInput.style.borderColor = ''; } } else { const repsInput = document.getElementById(`reps-${exerciseName}-${setIndex}`); if (!repsInput) { console.warn(`Input not found for ${exerciseName} Set ${i + 1} Reps`); continue; } const reps = parseInt(repsInput.value, 10); if (isNaN(reps) || reps < 0) { formIsValid = false; if (repsInput) repsInput.style.borderColor = 'var(--color-danger)'; } else { setData.reps = reps; if (repsInput) repsInput.style.borderColor = ''; } if (!isRepsOnly) { const weightInput = document.getElementById(`weight-${exerciseName}-${setIndex}`); if (!weightInput) { console.warn(`Input not found for ${exerciseName} Set ${i + 1} Weight`); continue; } const weight = parseFloat(weightInput.value); if (isNaN(weight) || weight < 0) { formIsValid = false; if (weightInput) weightInput.style.borderColor = 'var(--color-danger)'; } else { setData.weight = weight; if (weightInput) weightInput.style.borderColor = ''; } } } sessionData.exercises[exerciseName].push(setData); } }); if (!formIsValid) { feedbackEl.textContent = "Please fill in all strength fields correctly (ensure RPE is selected)."; feedbackEl.className = 'error'; return; } saveStrengthData(strengthData); feedbackEl.textContent = `Strength Session for ${dateFormatted} Saved Successfully!`; feedbackEl.className = 'success'; console.log(`Saved strength data for ${dateFormatted}:`, sessionData); if (isViewingPreviousStrength) { switchToCurrentDayView(); } else { initializeAppUI(currentViewDate); /* Refresh current view to update last session panel */ setTimeout(() => { feedbackEl.textContent = ''; feedbackEl.className = ''; }, 3000); } }
        function handleViewPrevious() { /* ... same ... */ isViewingPreviousStrength = true; prevDateSelectorDiv.style.display = 'block'; viewPrevButton.style.display = 'none'; backToCurrentButton.style.display = 'inline-block'; rightPanelTitleEl.textContent = 'View/Add Past Strength'; rightPanelContentEl.innerHTML = '<p>Select a date and click "Load Strength Date".</p>'; feedbackEl.textContent = ''; feedbackEl.className = ''; const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); prevDateInput.value = getFormattedDate(yesterday); }
        function handleLoadPrevious() { /* ... same ... */ const selectedDateStr = prevDateInput.value; if (!selectedDateStr) { feedbackEl.textContent = 'Please select a date.'; feedbackEl.className = 'error'; return; } feedbackEl.textContent = ''; feedbackEl.className = ''; const selectedDate = new Date(selectedDateStr + 'T00:00:00'); const today = new Date(); today.setHours(0, 0, 0, 0); if (selectedDate > today) { feedbackEl.textContent = 'Cannot view or add data for a future date.'; feedbackEl.className = 'error'; return; } currentViewDate = selectedDate; const strengthWorkoutType = STRENGTH_WORKOUT_SCHEDULE[selectedDate.getDay()]; if (!strengthWorkoutType) { rightPanelTitleEl.textContent = `Not a Strength Day (${selectedDateStr})`; rightPanelContentEl.innerHTML = '<p>This was not a scheduled strength day (Push/Pull/Legs).</p>'; return; } const sessionDataForDate = strengthData[selectedDateStr] ?? null; rightPanelTitleEl.textContent = `${strengthWorkoutType} Session (${selectedDateStr})`; renderStrengthPanel(selectedDate, STRENGTH_EXERCISES[strengthWorkoutType], sessionDataForDate, { isPast: true }); }
        function switchToCurrentDayView() {
            isViewingPreviousStrength = false;
            currentViewDate = new Date(); // Reset view date to today
            prevDateSelectorDiv.style.display = 'none'; // Hide selector
            viewPrevButton.style.display = 'inline-block'; // Show view button
            backToCurrentButton.style.display = 'none'; // Hide back button
            feedbackEl.textContent = ''; feedbackEl.className = '';
            // Reload the main view for today by calling the UI update function
            initializeAppUI(currentViewDate);
        }
        function handleCardioMarkComplete() { /* ... same ... */ if (cardioCurrentlyDisplayedIndex === cardioFirstIncompleteIndex && cardioCurrentlyDisplayedIndex !== -1) { const sessionToComplete = cardioSessions[cardioCurrentlyDisplayedIndex]; cardioCompletionStatus[sessionToComplete.date] = true; saveCardioCompletionStatus(); cardioFirstIncompleteIndex = findFirstIncompleteCardioIndex(); renderCardioPanel(cardioFirstIncompleteIndex); } else { console.error("Attempted to complete a cardio session that isn't the next due one."); } }
        function handleCardioPrevious() { /* ... same ... */ if (cardioCurrentlyDisplayedIndex > cardioFirstIncompleteIndex) { renderCardioPanel(cardioCurrentlyDisplayedIndex - 1); } }
        function handleCardioNext() { /* ... same ... */ if (cardioCurrentlyDisplayedIndex < cardioSessions.length - 1) { renderCardioPanel(cardioCurrentlyDisplayedIndex + 1); } }
        function displayChart(chartType) { /* ... same ... */ console.log("Switching chart to:", chartType); currentChartType = chartType; chartTitleEl.textContent = (chartType === 'single') ? 'Progression Chart (Single DB)' : 'Progression Chart (Double DB)'; renderProgressionChart(chartType); if (chartType === 'single') { showSingleDbBtn.classList.add('active-chart-btn'); showDoubleDbBtn.classList.remove('active-chart-btn'); } else { showDoubleDbBtn.classList.add('active-chart-btn'); showSingleDbBtn.classList.remove('active-chart-btn'); } }

        // --- Rep Range Configuration ---
        const DEFAULT_REP_RANGE = { min: 8, max: 12 };
        const SPECIFIC_REP_RANGES = {
            // Add exercises here with their specific ranges
            'Standing Calf Raise': { min: 12, max: 24 },
            'Shrug': { min: 12, max: 24 }
        };

        // --- Core Logic ---
        // findLastSessionDate() should be here...

        function getWorkoutInfoForDate(date) {
            const dayOfWeek = date.getDay(); // 0=Sun, 1=Mon... 6=Sat
            if (STRENGTH_WORKOUT_SCHEDULE[dayOfWeek]) {
                const type = STRENGTH_WORKOUT_SCHEDULE[dayOfWeek];
                return { type: type, exercises: [...STRENGTH_EXERCISES[type]], category: 'Strength' };
            } else if (CARDIO_TRAINING_DAYS.includes(dayOfWeek)) {
                return { type: 'Cardio', exercises: [], category: 'Cardio' }; // No specific exercises needed here
            } else {
                return { type: 'Rest', exercises: [], category: 'Rest' };
            }
        }

        // initializeAppUI() is defined after this...

        // --- Initialization V17 ---
        function initializeAppUI(dateToShow) {
            dateToShow.setHours(0, 0, 0, 0); currentViewDate = dateToShow;
            // --- Keep retro strength button visible REGARDLESS of today's type ---
            // isViewingPreviousStrength = false; // Reset mode only when switching explicitly
            // prevDateSelectorDiv.style.display = 'none'; // Handled by toggle functions now
            // viewPrevButton.style.display = 'inline-block'; // Always show this
            // backToCurrentButton.style.display = 'none'; // Hide this initially
            // ---
            feedbackEl.textContent = ''; feedbackEl.className = '';
            currentDateEl.textContent = `Date: ${dateToShow.toDateString()}`;
            const workoutInfo = getWorkoutInfoForDate(dateToShow);
            workoutTypeEl.textContent = `Type: ${workoutInfo.type}`;

            // Always render the last STRENGTH session panel on the left
            // Render Last Strength Session Panel V17 - Sets title
            function renderLastStrengthSession() {
                const lastSessionDateStr = findLastSessionDate(new Date(), null, strengthData, true); // Find last strength session date regardless of type
                const lastSessionData = lastSessionDateStr ? strengthData[lastSessionDateStr] : null;
                let title = "Last Strength Session"; // Default title

                if (!lastSessionData || !lastSessionData.exercises) {
                    lastSessionInfoEl.innerHTML = '<p>No previous strength data.</p>';
                    title = "Strength History"; // More generic title if empty
                } else {
                    // Display logic similar to V9/V10 but simplified
                    title = `Last Strength (${lastSessionData.type} - ${lastSessionData.date})`; // More specific title
                    let html = ''; // Start empty, only add if data exists
                    const strengthType = lastSessionData.type; // e.g., 'Push'
                    const originalOrder = STRENGTH_EXERCISES[strengthType] || Object.keys(lastSessionData.exercises);
                    originalOrder.forEach(exerciseName => {
                        if (!lastSessionData.exercises[exerciseName]) return;
                        html += `<div class="exercise"><h5>${exerciseName}</h5>`; // Smaller display
                        html += lastSessionData.exercises[exerciseName].map((set, index) => {
                            let setDetails = ''; const setData = set || {};
                            if (TIME_BASED_EXERCISES.includes(exerciseName)) { setDetails = `T: ${setData.time ?? 'N/A'}s @ ${setData.rpe ?? 'N/A'}`; }
                            else if (REPS_ONLY_EXERCISES.includes(exerciseName)) { setDetails = `R: ${setData.reps ?? 'N/A'} @ ${setData.rpe ?? 'N/A'}`; }
                            else { setDetails = `W: ${setData.weight ?? 'N/A'}kg x ${setData.reps ?? 'N/A'}r @ ${setData.rpe ?? 'N/A'}`; }
                            return `<div class="set-info" style="font-size: 0.9em;">S${index + 1}: ${setDetails}</div>`;
                        }).join('');
                        html += `</div>`;
                    });
                    lastSessionInfoEl.innerHTML = html;
                }
                // Update the panel title
                leftPanelTitleEl.textContent = title;
            }

            rightPanelContentEl.innerHTML = ''; // Clear right panel

            // --- Render Right Panel based on Category ---
            if (workoutInfo.category === 'Strength') {
                rightPanelTitleEl.textContent = `${workoutInfo.type} Session`;
                // Show strength retro button (already visible)
                // viewPrevButton.style.display = 'inline-block';
                const currentRecommendations = {}; workoutInfo.exercises.forEach(exName => { const lastSet = strengthData[findLastSessionDate(dateToShow, workoutInfo.type, strengthData)]?.exercises?.[exName]?.slice(-1)[0] ?? null; currentRecommendations[exName] = getStrengthRecommendation(exName, lastSet); }); const optimalSequence = getOptimalStrengthSequence(workoutInfo.exercises, currentRecommendations); renderStrengthPanel(dateToShow, optimalSequence, null, { isPast: false });
            }
            else if (workoutInfo.category === 'Cardio') {
                rightPanelTitleEl.textContent = `Cardio Session`;
                // Hide strength retro button logic is handled within its own toggle now
                // viewPrevButton.style.display = 'none';
                const dateStr = getFormattedDate(dateToShow); const sessionIndex = cardioSessions.findIndex(s => s.date === dateStr);
                if (sessionIndex !== -1) { renderCardioPanel(sessionIndex); }
                else { rightPanelContentEl.innerHTML = '<p>Error: Cardio session not found for this date.</p>'; }
            }
            else { // Rest Day
                rightPanelTitleEl.textContent = "Rest Day";
                // Hide strength retro button logic is handled within its own toggle now
                // viewPrevButton.style.display = 'none';
                rightPanelContentEl.innerHTML = '<p style="text-align: center; margin-top: 50px; font-size: 1.2em;">Enjoy your rest!</p>';
            }
        }

        function initializeApp() {
            // 1. Generate ALL data sets
            doubleDbWeights = generateDoubleDbWeights(); singleDbWeights = generateSingleDbWeights(); cardioSessions = generateCardioSessions();
            // 2. Load existing data
            strengthData = loadStrengthData(); cardioCompletionStatus = loadCardioCompletionStatus(); cardioFirstIncompleteIndex = findFirstIncompleteCardioIndex();
            // 3. Render the initial chart view (Double DB)
            displayChart('double');
            // 4. Setup initial UI for TODAY
            initializeAppUI(new Date());
            // 5. Add Global Event Listeners
            viewPrevButton.addEventListener('click', handleViewPrevious); loadPrevButton.addEventListener('click', handleLoadPrevious); backToCurrentButton.addEventListener('click', switchToCurrentDayView);
            showDoubleDbBtn.addEventListener('click', () => displayChart('double')); showSingleDbBtn.addEventListener('click', () => displayChart('single'));
            // Note: Dynamic buttons (Save, Cardio Nav/Complete) have listeners added when rendered
        }

        // --- Run App ---
        initializeApp();

    </script>
</body>

</html>